# Securing XPC Interfaces with NSXPCInterface

**Securing an XPC service** involves both restricting the types of objects that can be sent over the connection and validating the clients that connect. Apple’s XPC API provides mechanisms to **whitelist allowed classes for method parameters** and enforce **NSSecureCoding**, which together prevent deserialization attacks. Additionally, developers should implement **connection-level authentication** to ensure only trusted clients can communicate with the service. Below, we detail how to use NSXPCInterface to restrict classes, how to harden XPC methods against malicious input, and general best practices for secure XPC service implementation.

## Restricting Allowed Classes with NSXPCInterface

**The correct API for restricting allowed classes** on XPC method arguments is the NSXPCInterface.setClasses(\_:forSelector:argumentIndex:ofReply:) method. This method allows you to specify exactly which classes (and container classes) are permitted for a given method parameter or reply argument. By default, **XPC only allows known safe Foundation classes** (such as NSArray, NSDictionary, NSString, NSNumber, NSData, NSDate, etc.) that conform to NSSecureCoding[\[1\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20,protocol). If you need to send custom objects or collections of objects, you must explicitly whitelist those classes in the interface:

- **Identify the method and parameter index** that needs class restriction. The first parameter is index 0, the second is 1, and so on[\[2\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20first%20parameter%20to%20a,parameter%201%2C%20and%20so%20on). For reply block parameters, you will use ofReply: true.

- **Create a set of allowed classes**, including the container class (e.g. NSArray or NSDictionary) and the element class(es) that will be inside. Only these classes will be allowed during decoding[\[3\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=classes%20that%20can%20appear%20within,those%20containers)[\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20).

- **Call** setClasses(\_:forSelector:argumentIndex:ofReply:) on your NSXPCInterface object, passing the NSSet of classes, the selector for the method, the argument index, and ofReply boolean.

For example, suppose an XPC method takes an array of FrenchFry objects as a parameter. In Objective-C you would whitelist the class like this:

NSXPCInterface \*interface \= \[NSXPCInterface interfaceWithProtocol:@protocol(FeedMeABurgerAndFries)\];  
NSSet \*allowed \= \[NSSet setWithObjects:\[NSArray class\], \[FrenchFry class\], nil\];  
\[interface setClasses:allowed
forSelector:@selector(feedMeFries:)
argumentIndex:0
ofReply:NO\];

This whitelists FrenchFry for the first argument of feedMeFries: (which is an NSArray of fries)[\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20)[\[5\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=argumentIndex%3A%200%20%20%2F%2F%20the,first%20parameter). If the method had a reply block that returned an array of custom objects, you would pass ofReply:YES for that reply parameter[\[2\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20first%20parameter%20to%20a,parameter%201%2C%20and%20so%20on). By doing this, the XPC runtime will **only decode objects of the specified classes** for that parameter, rejecting anything unexpected.

**Using the API in Swift:** In Swift, the same setClasses method exists, but you must bridge Swift class objects into an NSSet. Class types do not conform to Hashable in Swift, so you can create an NSSet then cast to Set\<AnyHashable\>. For example:

let allowedClasses: Set\<AnyHashable\> \= NSSet(objects: NSArray.self, FrenchFry.self) as\! Set\<AnyHashable\>  
interface.setClasses(allowedClasses, for: \#selector(FeedMeABurgerAndFries.feedMeFries(\_:)), argumentIndex: 0, ofReply: false)

Here we include NSArray.self and FrenchFry.self in the allowed set. Notably, any custom classes must be marked with @objc and subclass NSObject to be transported over XPC[\[6\]](https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface#:~:text=The%20classes%20you%20pass%20need,then%20cast%20that%20to%20Set). The need to cast via NSSet is a known quirk of the API in Swift[\[7\]](https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface#:~:text=let%20classSet%20%3D%20NSSet%28object%3A%20Foo,AnyHashable). Once set up, the interface will enforce that only NSArray containing FrenchFry objects is allowed for that parameter. If a malicious client tries to send an object of a different class, the XPC system will throw an exception and **drop the message** (preventing deserialization)[\[8\]](https://stackoverflow.com/questions/16765421/xpc-not-registering-classes-correctly-for-collection#:~:text=,NSDictionary%2C%20NSString%2C%20NSDate%2C%20NSData).

## NSSecureCoding and Deserialization Security

**NSSecureCoding is mandatory** for any custom classes sent over XPC. Apple’s documentation emphasizes that _“only classes that conform to NSSecureCoding can be sent”_ over an NSXPCConnection[\[1\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20,protocol). Ensure your custom classes implement NSSecureCoding (with supportsSecureCoding \= true) and properly validate types in init(coder:) (using decodeObjectOfClass: or decodeObjectOfClasses:)[\[9\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=,YES)[\[10\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=In%20that%20method%2C%20when%20decoding,can%20appear%20within%20the%20collection). This prevents a common flaw where a crafted payload could be deserialized as an unexpected class. By combining NSSecureCoding with the class whitelist on the interface, you create a two-layer defense against **object substitution attacks**:

- The interface whitelist ensures the **NSCoder only allows specific classes** during decoding for each parameter[\[8\]](https://stackoverflow.com/questions/16765421/xpc-not-registering-classes-correctly-for-collection#:~:text=,NSDictionary%2C%20NSString%2C%20NSDate%2C%20NSData). If an incoming XPC message contains a disallowed class (even one that claims to implement NSSecureCoding), decoding will fail with an error like “value for key 'NS.objects' was of unexpected class” and the message will be rejected[\[8\]](https://stackoverflow.com/questions/16765421/xpc-not-registering-classes-correctly-for-collection#:~:text=,NSDictionary%2C%20NSString%2C%20NSDate%2C%20NSData).

- NSSecureCoding in your class’s implementation ensures that even if decoding is attempted, the class itself will refuse or safely handle unexpected subclass data.

**Tip:** If your XPC method parameters include container types (NSArray, NSDictionary, NSSet, etc.), include the container class itself in the allowed set along with element classes[\[11\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=Most%20of%20the%20time%2C%20custom,can%20appear%20within%20those%20containers)[\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20). Foundation collection classes are _not_ automatically whitelisted by secure decoding, so they must be explicitly allowed when used as top-level parameters[\[12\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=When%20generating%20the%20list%20of,be%20aware%20of%20two%20things)[\[13\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=First%2C%20Apple%20collection%20classes%20are,the%20array%20of%20class%20types). For example, whitelisting \[NSArray class\] alongside your element class ensures the array itself is recognized as allowed data to deserialize[\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20). You do **not** need to whitelist classes that only appear nested inside other objects (your NSSecureCoding implementation will handle those), only those that appear as direct parameters or within top-level collections[\[14\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=serialization%2C%20read%20Serializing%20Property%20Lists,in%20%2025).

Beyond class restrictions, **validate the content** of objects once decoded. Whitelisting prevents dangerous classes, but you should still verify that data is within expected ranges or formats (e.g. check string lengths, enum values, file paths etc.) to avoid logic bombs or injection via seemingly valid objects. In summary, use NSXPCInterface to strictly limit what _types_ can cross the boundary, and use defensive coding to ensure the _values_ make sense.

## Connection-Level Authentication and Client Validation

Even with robust object handling, an XPC service must ensure that only authorized clients can connect. The NSXPCListenerDelegate’s listener(\_:shouldAcceptNewConnection:) gives you an opportunity to **inspect and validate the incoming connection** before allowing it. By default, if you simply return true (or YES), _any process that knows the service’s Mach name can connect_. This can be a serious vulnerability if the XPC service performs privileged actions. For instance, Apple’s SafariBookmarksSyncAgent service used to accept all connections unconditionally, which meant **any process on the system could communicate with it**[\[15\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=Since%20,and%20communicate%20with%20the%20daemon) (this was the root cause of CVE-2020-9977). The lesson is clear: **never blindly accept every connection**.

**Best practices for shouldAcceptNewConnection:**

- **Validate the client’s identity.** You can retrieve the connecting process ID via newConnection.processIdentifier, but PIDs can be reused and are not secure for authorization. A more robust approach is to examine the code signature or team identifier of the client process. Apple does not expose a public API for getting the audit token in Swift, but in Objective-C you can use the private auditToken or C functions (like xpc_connection_get_audit_token). Advanced implementations use SecCodeCopySigningInformation or SecCodeCheckValidity on the connecting process’s audit token to ensure it’s signed by your developer Team ID or has a specific code requirement[\[16\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=The%20,satisfy%20one%20of%20these%20requirements)[\[17\]](https://theevilbit.github.io/posts/secure_coding_xpc_part2/#:~:text=Is%20the%20XPC%20service%20verifies,this%20is%20not%20frequently%20seen). For example, the **Proxyman** helper tool explicitly defined acceptable code-signing requirements (the bundle IDs and certificate of the legitimate app) and only accepts the connection if the client satisfies one of those requirements[\[18\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=The%20,satisfy%20one%20of%20these%20requirements)[\[19\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=r12%20%3D%20rax%3B%20rdx%20%3D,exists). In Swift, achieving the same may require bridging to C APIs or using an Objective-C helper, but the principle is to **allow only your app (or a narrow set of signed apps)** to connect.

- **Use entitlements or requirements where possible.** If your XPC service is a **privileged helper (LaunchDaemon)** installed via SMJobBless, you can embed client requirements in its launchd plist or code (as seen with Proxyman above). If it’s a bundled XPC service inside your app, macOS will automatically use the app’s code signature for launching it, but not necessarily restrict other clients after launch. Consider using a **custom entitlement** that only your app possesses (and check newConnection.value(forEntitlement:)), or rely on the Team ID check as described.

- **Reject or restrict untrusted connections.** If a connection comes from an unexpected source, call newConnection.invalidate() and return false from shouldAcceptNewConnection. You can log or handle these events as potential intrusion attempts. In many cases, simply **returning false for unknown clients** will mitigate confused deputy attacks, where a malicious app tries to piggyback on your XPC service.

- **Limit the XPC listener’s exposure.** Use the **lowest privileges** needed for your service. For example, if your service runs as the same user as the client, the risk is contained to that user session (though still consider other apps by that user). If it runs as root or a different user, client validation is even more critical. Also, if your service is only intended for in-app use, there's no need to advertise it system-wide – keep the service within your app’s bundle so only your app normally knows how to call it. (In sandboxed apps, XPC services are automatically namespaced, but in non-sandboxed contexts, an attacker might still discover the service name.)

By implementing these checks, you ensure that even if an attacker crafts malicious data, they **first have to be an authorized client** to even send anything. A well-secured XPC service like Apple’s (fixed) implementations will verify the client’s code signature via the audit token and only then proceed to handle requests[\[17\]](https://theevilbit.github.io/posts/secure_coding_xpc_part2/#:~:text=Is%20the%20XPC%20service%20verifies,this%20is%20not%20frequently%20seen). This dramatically raises the bar for attackers.

## Summary of XPC Security Best Practices

1. **Use NSXPCInterface to whitelist classes** for each method argument and reply. Disallow all but the expected classes (and container types) to prevent object substitution attacks[\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20)[\[5\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=argumentIndex%3A%200%20%20%2F%2F%20the,first%20parameter). Always include foundation collection classes in the allowed set if they carry your objects.

2. **Require NSSecureCoding** for any custom object crossing the XPC boundary. Implement \+supportsSecureCoding and use secure decoding methods to validate types inside init(coder:)[\[20\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=All%20objects%20passed%20over%20an,class%20must%20do%20the%20following)[\[21\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=,can%20appear%20within%20the%20collection). This ensures unknown classes or corrupted data won’t be trusted during decoding.

3. **Keep method data simple and safe.** Prefer primitive types (Int, Bool, etc.), Data (for binary blobs), or well-defined model objects. Avoid sending raw Any or loosely typed collections if possible. The stricter your interface, the less room for abuse.

4. **Validate inputs explicitly.** Even after class-checking, verify that strings are properly formed, numbers are within expected range, file paths point to allowed locations, etc. Treat the XPC client as an untrusted source of data.

5. **Implement client authentication in shouldAcceptNewConnection.** Do not assume only your app will connect. Check the connecting process’s identity (team identifier, bundle ID, or entitlement) and reject connections from unknown or unauthorized sources[\[15\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=Since%20,and%20communicate%20with%20the%20daemon)[\[18\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=The%20,satisfy%20one%20of%20these%20requirements). For high-privilege services, this step is critical.

6. **Principle of least privilege.** Run the XPC service with the minimum privileges required. If it doesn’t need disk or network access, sandbox it or limit its entitlements. If it runs as root (for a privileged helper), ensure it performs strict client validation and only does the narrow tasks it's designed for.

7. **Test with malicious scenarios.** Create sample “attacker” clients that try to send disallowed classes or invalid data to your XPC service. Ensure that your class whitelist and secure coding throw exceptions or safely handle the input (the call should fail rather than causing a crash or, worse, succeeding unexpectedly).

By following these practices, you can significantly **harden your XPC service**. The combination of class whitelisting on the interface and robust client checks has been repeatedly shown to prevent real-world vulnerabilities. For instance, Apple addressed issues where XPC services were too permissive by adding code-signing checks and class restrictions in updates[\[15\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=Since%20,and%20communicate%20with%20the%20daemon)[\[17\]](https://theevilbit.github.io/posts/secure_coding_xpc_part2/#:~:text=Is%20the%20XPC%20service%20verifies,this%20is%20not%20frequently%20seen). In summary, **be explicit about what you accept** – both in terms of object classes and client processes. This will protect your AgentFSKitExtension XPC service from deserialization attacks and unauthorized use, across all current macOS versions (the NSXPCInterface APIs and concepts apply from macOS 10.8 through macOS 14+ and beyond). With Swift, the tools are slightly cumbersome but entirely available to implement these security measures.

## References

- Apple Developer Documentation – _NSXPCInterface Class Reference_ (see setClasses:forSelector:argumentIndex:ofReply:)[\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20)[\[5\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=argumentIndex%3A%200%20%20%2F%2F%20the,first%20parameter)

- Apple Developer Documentation – _Creating XPC Services_ (Secure Coding and whitelisting guidance)[\[1\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20,protocol)[\[11\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=Most%20of%20the%20time%2C%20custom,can%20appear%20within%20those%20containers)

- Stack Overflow – _Swift NSXPCInterface class whitelisting issue_ (workaround for Swift Set\<AnyHashable\> usage)[\[6\]](https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface#:~:text=The%20classes%20you%20pass%20need,then%20cast%20that%20to%20Set)

- Parnham, J. (2023) – _SafariBookmarksSyncAgent XPC vulnerability (CVE-2020-9977) write-up_[\[15\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=Since%20,and%20communicate%20with%20the%20daemon)[\[22\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=NSSet%20,arrayWithObjects)

- Fox-IT (2023) – _Technical Advisory: Insufficient XPC Validation in Proxyman Helper_ (example of code-sign requirement checks in shouldAcceptNewConnection)[\[18\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=The%20,satisfy%20one%20of%20these%20requirements)

- Csaba Fitzl – _Secure Coding XPC Services_ blog series (client verification via audit tokens, etc.)[\[17\]](https://theevilbit.github.io/posts/secure_coding_xpc_part2/#:~:text=Is%20the%20XPC%20service%20verifies,this%20is%20not%20frequently%20seen)

---

[\[1\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20,protocol) [\[2\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=The%20first%20parameter%20to%20a,parameter%201%2C%20and%20so%20on) [\[3\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=classes%20that%20can%20appear%20within,those%20containers) [\[4\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=NSSet%20) [\[5\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=argumentIndex%3A%200%20%20%2F%2F%20the,first%20parameter) [\[9\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=,YES) [\[10\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=In%20that%20method%2C%20when%20decoding,can%20appear%20within%20the%20collection) [\[11\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=Most%20of%20the%20time%2C%20custom,can%20appear%20within%20those%20containers) [\[12\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=When%20generating%20the%20list%20of,be%20aware%20of%20two%20things) [\[13\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=First%2C%20Apple%20collection%20classes%20are,the%20array%20of%20class%20types) [\[14\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=serialization%2C%20read%20Serializing%20Property%20Lists,in%20%2025) [\[20\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=All%20objects%20passed%20over%20an,class%20must%20do%20the%20following) [\[21\]](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#:~:text=,can%20appear%20within%20the%20collection) Creating XPC Services

[https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html)

[\[6\]](https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface#:~:text=The%20classes%20you%20pass%20need,then%20cast%20that%20to%20Set) [\[7\]](https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface#:~:text=let%20classSet%20%3D%20NSSet%28object%3A%20Foo,AnyHashable) hashable \- Swift 5: How to make a Set containing Class Types (for NSXPCInterface) \- Stack Overflow

[https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface](https://stackoverflow.com/questions/56011613/swift-5-how-to-make-a-set-containing-class-types-for-nsxpcinterface)

[\[8\]](https://stackoverflow.com/questions/16765421/xpc-not-registering-classes-correctly-for-collection#:~:text=,NSDictionary%2C%20NSString%2C%20NSDate%2C%20NSData) objective c \- XPC not registering classes correctly for collection \- Stack Overflow

[https://stackoverflow.com/questions/16765421/xpc-not-registering-classes-correctly-for-collection](https://stackoverflow.com/questions/16765421/xpc-not-registering-classes-correctly-for-collection)

[\[15\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=Since%20,and%20communicate%20with%20the%20daemon) [\[22\]](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/#:~:text=NSSet%20,arrayWithObjects) Josh Parnham \- Accessing sensitive Safari browsing data on macOS (CVE-2020-9977)

[https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/](https://joshparnham.com/2023/08/accessing-sensitive-safari-browsing-data-on-macos-cve-2020-9977/)

[\[16\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=The%20,satisfy%20one%20of%20these%20requirements) [\[18\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=The%20,satisfy%20one%20of%20these%20requirements) [\[19\]](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/#:~:text=r12%20%3D%20rax%3B%20rdx%20%3D,exists) Technical Advisory: Insufficient Proxyman HelperTool XPC Validation | Fox IT

[https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/](https://www.fox-it.com/be/technical-advisory-insufficient-proxyman-helpertool-xpc-validation/)

[\[17\]](https://theevilbit.github.io/posts/secure_coding_xpc_part2/#:~:text=Is%20the%20XPC%20service%20verifies,this%20is%20not%20frequently%20seen) Secure coding XPC Services \- Part 2 \- Checking CS (CodeSigning) flags of the client · theevilbit blog

[https://theevilbit.github.io/posts/secure_coding_xpc_part2/](https://theevilbit.github.io/posts/secure_coding_xpc_part2/)
