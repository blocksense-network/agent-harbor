# Intercepting Terminal I/O via an FSKit Overlay

## Mounting a Proxy for /dev/tty in User-Space FS

Yes – you **can** mount a dummy or “proxy” file in place of the terminal device (e.g. replacing /dev/tty) using your FSKit-based user-space filesystem. In practice, you would present /dev/tty inside the chroot as a regular file (not an actual TTY character device) that your filesystem module controls. This means any attempts by the monitored process to open or read/write the terminal will go through your custom FS handlers, allowing you to implement the desired blocking or filtering logic. In essence, you are exposing what the process perceives as the terminal **as a normal file stream under your control**[\[1\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=can%20be%20compromised). This approach is analogous to how one might expose a disk partition to unprivileged code as a regular file instead of a real block device – it avoids giving direct device access while still allowing I/O operations[\[2\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=If%20I%20understand%20correctly%2C%20you,doesn%27t%20work%20for%20security%20reasons).

By intercepting the open of /dev/tty, you ensure the process obtains a file descriptor backed by your user-space FS. All reads and writes on that FD will invoke your FSKit module’s callbacks (similar to FUSE behavior). This gives you an opportunity to block until certain conditions are met or to log/modify data as needed. For example, if your goal is to **block input/output** until some criteria are satisfied, your FS can simply not return read data (or not complete write operations) until the condition is fulfilled. In effect, your FS module acts as a man-in-the-middle for the terminal stream.

**Tip:** Present the proxy as a plain file/pipe in the overlay, _not_ a real character device node. If you tried to create a genuine character device with the TTY’s major/minor numbers, the kernel would attempt to use the actual TTY driver (bypassing your FS) or might outright deny access in a user FS mount (for security)[\[2\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=If%20I%20understand%20correctly%2C%20you,doesn%27t%20work%20for%20security%20reasons). Using a regular file interface ensures the kernel treats it as a normal file on your filesystem, so all I/O goes through your code instead of an underlying device driver. (For instance, in a FUSE setup, device special files are typically disallowed or require special mount options[\[3\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=While%20reading%20the%20manpages%20I,which%20made%20my%20heart%20sink) – by avoiding a device node, you keep control in user-space.)

## Ensuring All Terminal Interactions Are Captured

Mounting the proxy file is only half the battle – you must also **prevent the process from interacting with any real TTY outside your control.** This means configuring the process’s environment such that _all_ of its terminal I/O attempts funnel into your FS overlay:

- **Start with clean file descriptors:** Make sure that when you launch the process in the chroot, it does not inherit any open file descriptor referring to the real console or a parent terminal. For example, if the process inherits an already-open STDIN/STDOUT that is a real terminal device from the parent, it could write to that directly, bypassing your filesystem. To guard against this, close or redirect standard streams before exec. Ideally, open your fake /dev/tty from the overlay and dup that into FD 0,1,2 for the process. This way, from the moment it starts, the process is tied into your pseudo-terminal file. In a hardened container scenario, the first process is launched with **no descriptors pointing outside** the chroot, specifically to prevent escaping the I/O sandbox[\[4\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%2A%20To%20prevent%20the%20chdir%28,arbitrary%20filesystem%20reads%20and%20writes). You should do the same so that the **only** terminal-like interface available is the one your FS provides.

- **Remove or override other TTY paths:** Ensure that _all_ typical terminal device paths are intercepted or absent in the chroot. On macOS, besides /dev/tty, processes might try other interfaces. For instance, /dev/ptmx is the pseudo-terminal multiplexer used to create new pty pairs – if a monitored application opens /dev/ptmx, it would spawn a new kernel-managed pty device (with a new /dev/ttys\#\#\# slave) outside your control[\[5\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=Instead%2C%20when%20one%20opens%20up,who). To prevent this, you should mount an inert proxy at /dev/ptmx as well (or omit it entirely) so that the call cannot create a real pty. Similarly, be aware that macOS retains legacy BSD pty devices (e.g. /dev/ptyXY and corresponding /dev/ttyXY pairs) for compatibility[\[6\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=command%20inputs,who)[\[7\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=2). A process _could_ attempt to open one of those static pty devices directly. Unless your overlay hides those, such an open would yield a real kernel TTY endpoint (circumventing your overlay). In short, **the chroot’s /dev should contain only your controlled devices** (and basic things like null/random) – no real TTY endpoints. If your overlay fully covers the /dev tree, make sure to “whitelist” only safe pseudo-files. For example, container runtimes typically mount a minimal /dev with just /dev/null, /dev/zero, /dev/tty, etc., and by default **exclude real TTY/PTY devices** or require explicit adds[\[8\]\[9\]](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/#:~:text=).

- **Detach from any controlling terminal:** When you start the process, consider running it in a new session (e.g. via setsid) so it has no controlling terminal on the host. Normally, if a process is started from an interactive shell, it inherits that shell’s TTY as controlling terminal. We want to avoid the host TTY from remaining as a backdoor. After a setsid, the first open of a tty device would usually become the controlling terminal – in this case, if the process opens /dev/tty (now routed to your FS), you can decide what happens. If it never acquires a controlling TTY (because your proxy isn’t a real tty driver), that’s fine too – it just means job-control signals or tcsetpgrp won’t function as they would on a real terminal. The key is that the _host’s_ TTY isn’t in play anymore. This prevents a slew of exploits; for example, if the real /dev/pts/X of an outside shell were accessible, an attacker could inject keystrokes into it via TIOCSTI ioctl (simulating user input to the outside terminal)[\[10\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%28same%20as%20,before%20returning%20to%20the%20shell). You definitely don’t want the monitored process able to write to the _actual_ terminal device of the user.

By launching the app in a carefully crafted chroot with a controlled /dev, you “fool” it into interacting with **your** filesystem’s terminal file. From its perspective, /dev/tty opens fine and reads/writes data – it doesn’t know that behind the scenes this is handled by your FS extension.

## TTY Semantics vs. Regular File Semantics

One challenge with this scheme is that a **real TTY device has special semantics** that a plain file does not. Programs may detect and rely on those semantics. Here are some considerations:

- **isatty() behavior:** Many programs check isatty(fileno(stdout)) to decide if they’re connected to an interactive terminal or not. Under the hood, isatty() usually works by attempting a TTY-specific ioctl (like TCGETS or TIOCGWINSZ) on the file descriptor and seeing if it fails with ENOTTY[\[11\]](https://stackoverflow.com/questions/56419346/how-does-the-libc-function-isatty-work#:~:text=10). If your proxy file is just a vanilla file, that ioctl **will** fail (since your FS doesn’t automatically implement termio ioctls). In other words, isatty() will return false, and the application may assume “not an interactive terminal” and change its behavior (e.g. turning off line buffering, or using a different output format). This could be undesirable if you _want_ the process to behave as if it’s on a real TTY. To mitigate this, you might need to handle certain ioctls in your FS module. FSKit (like FUSE) can support custom ioctls on FDs – you could intercept TIOCGWINSZ, TCGETS, etc., and return plausible responses rather than an error. For example, returning a fixed window size structure and “OK” for TIOCGWINSZ will make the program believe a terminal is present[\[11\]](https://stackoverflow.com/questions/56419346/how-does-the-libc-function-isatty-work#:~:text=10). Similarly, you might report default terminal settings for tcgetattr. This way, isatty() returns true and the program stays in interactive mode. Keep in mind you’d be **faking** these; if the program tries to set terminal modes (via tcsetattr, etc.), you would have to decide how to handle that. You could simply accept the ioctl and not actually enforce the flags (since your user-space FS isn’t a real line discipline), or implement minimal needed behavior (for instance, if it disables echo, perhaps your input-forwarding logic can honor that by not echoing back characters).

- **No built-in line discipline:** A real tty device (in canonical mode) buffers input until a newline/EOF and handles erase/kill processing, signals on Ctrl-C, etc. Your FS proxy by itself won’t do any of that unless you code it. If the application expects cooked mode input but you deliver raw characters, that could be confusing. However, many modern interactive programs put the terminal in raw mode and handle input themselves, in which case they won’t miss the line discipline. Still, be aware: to fully **mimic a terminal**, you may need to implement some extra logic (for example, you might choose to integrate a pseudo-tty under the hood of your FS file – using a real pty pair in the background – so that the kernel’s tty line discipline is still in effect). In simpler terms, your FSKit module could act as a broker between a real pty and the process: the process opens your /dev/tty (FS side), and your FS code in turn opens a PTY with the OS, forwarding data between the two. This would delegate all the complex tty behavior to the kernel, while still giving you a hook to monitor or block data. If using an actual pty is not desirable, you may keep things in pure user-space but then you must handle those details or accept differences (e.g. maybe the program will see an _unbuffered_ input stream).

- **Job control and signals:** Normally, the kernel sends signals like SIGINT, SIGTSTP, SIGWINCH to processes in the foreground of a terminal. If your monitored process has no true controlling tty, it won’t receive these automatically. That might be acceptable (for instance, maybe you don’t want it to intercept Ctrl-C at all), but it’s a change in behavior from a normal execution. If needed, you could manually deliver signals from your side (e.g. if the user tries to send an interrupt through your UI). Just note that by interposing on the terminal, you inherently alter some low-level behavior – most programs won’t notice beyond the isatty check, but shells or full-screen TUIs might.

In summary, **it is possible to intercept and control terminal I/O via a user-space filesystem**, but you should be prepared to **emulate or at least acknowledge** some terminal-specific features. Many implementations that require a pseudo-terminal (e.g. script(1) command or sandboxing tools) ultimately use a PTY because it cleanly provides these semantics. Doing it purely with an FS overlay is innovative – just test carefully with interactive programs to ensure they don’t misbehave due to the lack of a real tty driver.

## Possible Bypasses and How to Guard Against Them

Even with the above in place, consider all the ways the monitored process **might circumvent** your interception (intentionally or not):

- **Writing to an existing descriptor that bypasses the filesystem:** This is the most common loophole. If the process somehow retains a handle to a real device or file, any writes/reads on that handle won’t go through your FS. We already discussed ensuring no such FDs are inherited. Double-check file descriptors 0,1,2 at process start – they should point to your FS’s devices (or be closed). Also be wary of **library calls or frameworks** that might open devices behind your back. For instance, a library could directly call open("/dev/tty...") for some reason – but since your overlay covers those paths, it should still hit your FS (assuming you’ve covered all the names as mentioned). More sneaky are cases like /dev/stdin or /dev/fd/\*: on macOS, /dev/stdin is a symlink to /dev/fd/0 (which in turn refers to the process’s FD 0\)[\[12\]](https://github.com/neovim/neovim/issues/14049#:~:text=dev%2Fstdin%20not%20available%20in%20system,terminals%29). If a program opens /dev/stdin, the kernel will duplicate FD 0[\[13\]](https://lists.gnu.org/archive/html/help-bash/2025-02/msg00051.html#:~:text=,descriptor%201%20is%20duplicated). If your FD 0 is your proxy, that’s fine (it will dup your proxy FD). But if somehow FD 0 was the original tty, then opening /dev/stdin would give a direct handle to it. The lesson is that controlling the _initial_ FDs covers these cases too – they all eventually trace back to the underlying FD.

- **Creating a new TTY or alternate path:** As noted, a process could try to create a new terminal. This could be via posix_openpt()/grantpt() (which uses /dev/ptmx internally), or using old BSD ptys, or even contacting an external daemon for a console. If /dev/ptmx and /dev/pty\* are unavailable or stubbed out, these calls should fail or at least not escape your control. You should also ensure the process cannot directly talk to the WindowServer or any GUI to spawn a new Terminal window (though in a chroot without those privileges, that’s unlikely). Another corner: /dev/console – on macOS, /dev/console is the system console device. Unless the app is running as root and explicitly opens it, it probably won’t try, but if it did and your overlay doesn’t override /dev/console, it could write to the real console. The fix is the same: either include a dummy /dev/console or deny access (the safe default is that /dev/console isn’t even present in the chroot if you only populate a minimal dev). Essentially, **scrub the device namespace** of any target that you don’t want the app to use. Containerization docs often enumerate a minimal set of devices for this reason (e.g. Incus/LXD always provides a fixed list and nothing more)[\[8\]\[14\]](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/#:~:text=).

- **Abusing privileges (if running as root):** If the monitored process runs with **root** privileges inside the chroot, be extremely cautious. A root process can attempt to **create new device nodes** with mknod and thereby bypass the filesystem overlay. For example, with root access an application could mknod("/mychroot/dev/ttys005", S_IFCHR, \<major,minor\>) to create a real TTY device file that maps to a kernel TTY driver, or even create a **block device for the host disk**. There are known techniques where a root user in a chroot makes a device node for the host filesystem (e.g. /dev/sda1) and then mounts it to escape or manipulate data outside[\[15\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=FYI%20My%20use%20case%20is,question%20I%27m%20not%20looking%20for). In the context of terminals, a root process could conceivably create /dev/ptmx or /dev/tty with the correct device numbers and open it, thus circumventing your overlay file (since the kernel would see an actual device file and hand back a real device FD). To guard against this, **drop root privileges** for the target app if at all possible. If it must run as root, remove the ability to create device nodes – on Linux you’d bind-mount /dev with nodev option so mknod is blocked, but on macOS devfs and FSKit might behave differently. At the very least, your FSKit implementation should reject any mknod or create requests for device files. (If you don’t implement a “create special file” handler, the attempt might just fail with EPERM by default in user-space FS.) The bottom line: **root in chroot is dangerous** – chroot is not a security boundary by itself. As an example, even a fairly locked-down chroot environment warns that it’s not secure if the process has the ability to make device nodes or similar[\[16\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=packages%20there%20without%20exposing%20the,understand%20how%20secure%20it%20is)[\[17\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=,an%20interactive%20shell%20outside%20the). So minimize privileges and capabilities of the process so it cannot manufacture an escape hatch.

- **Networking or IPC escapes:** While not directly related to the tty, note that a process could potentially open a socket or other IPC to communicate outward (thus bypassing terminal controls). If your goal is _specifically_ to intercept terminal I/O, this might be out of scope. But just remember that chroot doesn’t restrict network access. A malicious process could, say, send data over a socket instead of stdout. Standard sandboxing would restrict that via other means (firewall or not granting socket access). Since your question focuses on terminal, I’ll assume you’re primarily concerned with interactive I/O, but it’s worth mentioning as part of “all possible bypasses.”

- **Flushing and direct syscalls:** Some programs might perform low-level terminal ops that assume a real TTY driver. For instance, an app might use ioctl(TIOCFLUSH) to flush input/output queues, or ioctl(TIOCSTI) to insert characters into the input buffer (though TIOCSTI is typically privileged or disabled on modern systems due to security concerns). If your FS doesn’t handle these, the calls may fail or no-op. Most likely this won’t enable an _escape_, but it could cause the program to behave oddly. For completeness, ensure that such calls either succeed benignly or are safely ignored. Another example is fcntl(F_SETFL, O_NONBLOCK) on the tty FD – your FS should honor non-blocking mode changes if the program expects them (e.g. don’t deadlock if it set nonblocking and is polling). Testing common interactive patterns (like running a shell or an editor) under your FS overlay will help uncover any such quirks to address.

## Hardening the Chroot Environment

To summarize the defensive measures against bypasses:

- **Minimal /dev in chroot:** Only include the device files your process truly needs – e.g. your fake tty, and perhaps standard null/zero/random. Omit or override anything like real ttys, ptmx, console, etc. This ensures _all_ paths for terminal access point to your FS module. (Recall that macOS provides a large number of /dev/tty\* and /dev/pty\* entries by default[\[6\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=command%20inputs,who) – these should not be visible to the app, except for the ones you explicitly want it to use.) If using an overlay, you might need to “whitelist” by creating stub entries; any device file not created in your overlay layer might fall back to the underlying filesystem’s device node, so be mindful. It might even be wise to mount an empty **devfs** in the chroot and then bind-mount your custom /dev/tty over it, to avoid inadvertently exposing something; however, with FSKit you likely want to manage it entirely in user-space.

- **No external FDs or handles:** As emphasized, start the process _after_ doing a chroot/pivot and closure of undesired file descriptors[\[4\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%2A%20To%20prevent%20the%20chdir%28,arbitrary%20filesystem%20reads%20and%20writes). Also drop it out of any controlling terminal on the host (use a new session). The parent launcher (which still has access outside) can then safely feed input or handle output via your FS.

- **Drop privileges:** Run the monitored process as an unprivileged user if possible. If it doesn’t need root, don’t give it root. This way even if it somehow sees a /dev entry, it can’t mknod a new one or open a restricted device. Many chroot jails run processes as a non-root UID for this reason – so that _even if_ there’s a kernel bug or mistake in the filesystem setup, the process can’t escalate easily. On macOS, if you’re using System Extensions / FSKit, you might already be constrained in running as root inside the extension, so design accordingly.

- **Intercept critical syscalls if needed:** The filesystem overlay should cover file-based access. But as an extra layer, you could consider interposing at the syscall level for certain calls using other mechanisms (for example, ptrace or the sandbox mechanism) – e.g., to catch if the process somehow tries an open("/dev/tty", ...) outside of your FS or uses an unexpected call. This is more of a belt-and-suspenders approach. Typically, a well-set-up chroot \+ FS overlay means any /dev/tty open will hit your code. However, watching for ioctl(TIOCSCTTY) or other obscure calls might reveal an app attempt to do something tricky with controlling terminals (in a normal setting, a session leader can call ioctl(pt_fd, TIOCSCTTY) on a pty to make it the controlling tty – if your app tried that on your fake tty FD, it would likely fail or be harmless, since your FD isn’t a real tty driver).

- **Testing for leaks:** It’s a good practice to test the jailed process with tools like lsof (from outside) or by monitoring system calls (using dtruss or similar on macOS) to ensure it isn’t accessing anything unexpected. For example, run the target app and then check that all its /dev/... accesses are going to your FS device and not something else. If you see an open of a device you didn’t account for, that’s a bypass you need to fix. In one hardened-chroot example, they explicitly list which devices were present and which not, to ensure nothing like /dev/mem or unauthorized tty was available[\[17\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=,an%20interactive%20shell%20outside%20the)[\[15\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=FYI%20My%20use%20case%20is,question%20I%27m%20not%20looking%20for).

By implementing these safeguards, you close off most avenues by which the process could circumvent your user-space filesystem monitoring. The combination of an overlay FS for _all filesystem interactions_ plus a tightly constrained chroot environment means the process should only “see” the resources you want it to see. All terminal reads/writes will be funneled through your FSKit module, letting you intercept or block them as intended.

## Final Thoughts

Using a user-space filesystem overlay to intercept terminal I/O is a powerful technique, especially now that macOS’s FSKit allows such extensions outside the kernel. It provides flexibility (since you can handle data in user-space) and avoids needing a custom kernel module. Just remember that a UNIX terminal isn’t a regular file – it has side channels and expectations that you need to manage. As long as you account for those (handling of isatty, termios ioctls, etc.) and lock down any alternate paths, your approach should work.

In summary: **Yes, you can mount a proxy file for the tty** and catch the data, but you must **thoroughly sandbox the process** to prevent it from writing to a real tty or spawning its own, and be prepared to **emulate basic terminal behavior** so the application doesn’t mis-detect its environment. This includes intercepting certain system calls that don’t go through the filesystem (like ioctl on the tty FD) and eliminating any unintended kernel-level device access. With all possible bypasses accounted for, your FSKit-based pseudo-tty can reliably intercept all interactions with the terminal.

**Sources:**

- FSKit discussion – moving filesystems to user space on macOS[\[18\]](https://eclecticlight.co/2024/06/26/how-file-systems-can-change-in-sequoia-with-fskit/#:~:text=Apple%E2%80%99s%20long,we%20have%20heard%20of%20it)[\[19\]](https://eclecticlight.co/2024/06/26/how-file-systems-can-change-in-sequoia-with-fskit/#:~:text=Before%20you%20all%20rush%20to,macFUSE%20anyone).

- Security best-practices for chroot jails (preventing access to host devices)[\[15\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=FYI%20My%20use%20case%20is,question%20I%27m%20not%20looking%20for)[\[17\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=,an%20interactive%20shell%20outside%20the).

- Unix StackExchange – using regular files vs block devices in FUSE (recommending exposing devices as normal files for safety)[\[2\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=If%20I%20understand%20correctly%2C%20you,doesn%27t%20work%20for%20security%20reasons)[\[1\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=can%20be%20compromised).

- Apple StackExchange – explanation of macOS pseudo-tty devices (use of /dev/ptmx and presence of legacy /dev/ttyXY nodes)[\[5\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=Instead%2C%20when%20one%20opens%20up,who)[\[6\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=command%20inputs,who).

- Stack Overflow – isatty() implementation detail (uses TTY ioctls and fails with ENOTTY on non-tty)[\[11\]](https://stackoverflow.com/questions/56419346/how-does-the-libc-function-isatty-work#:~:text=10).

- Incus/LXD container docs – default /dev devices provided in a container (illustrating minimal device set including /dev/tty but isolating others)[\[8\]\[14\]](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/#:~:text=).

- Hardened chroot example – ensuring no external FDs and limited capabilities for chroot process[\[4\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%2A%20To%20prevent%20the%20chdir%28,arbitrary%20filesystem%20reads%20and%20writes), and the risk of TIOCSTI on an external tty if left open[\[10\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%28same%20as%20,before%20returning%20to%20the%20shell).

---

[\[1\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=can%20be%20compromised) [\[2\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=If%20I%20understand%20correctly%2C%20you,doesn%27t%20work%20for%20security%20reasons) [\[3\]](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem#:~:text=While%20reading%20the%20manpages%20I,which%20made%20my%20heart%20sink) EPERM when formatting block device on a FUSE filesystem \- Unix & Linux Stack Exchange

[https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem](https://unix.stackexchange.com/questions/775084/eperm-when-formatting-block-device-on-a-fuse-filesystem)

[\[4\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%2A%20To%20prevent%20the%20chdir%28,arbitrary%20filesystem%20reads%20and%20writes) [\[10\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=%28same%20as%20,before%20returning%20to%20the%20shell) [\[15\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=FYI%20My%20use%20case%20is,question%20I%27m%20not%20looking%20for) [\[16\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=packages%20there%20without%20exposing%20the,understand%20how%20secure%20it%20is) [\[17\]](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av#:~:text=,an%20interactive%20shell%20outside%20the) security \- How to escape from a hardened chroot on Linux when only file capabilities are available to the attacker? \- Unix & Linux Stack Exchange

[https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av](https://unix.stackexchange.com/questions/492473/how-to-escape-from-a-hardened-chroot-on-linux-when-only-file-capabilities-are-av)

[\[5\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=Instead%2C%20when%20one%20opens%20up,who) [\[6\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=command%20inputs,who) [\[7\]](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev#:~:text=2) macos \- What is the purpose of the BSD pty/tty device files in /dev? \- Ask Different

[https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev](https://apple.stackexchange.com/questions/395439/what-is-the-purpose-of-the-bsd-pty-tty-device-files-in-dev)

[\[8\]](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/#:~:text=) [\[9\]](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/#:~:text=) [\[14\]](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/#:~:text=) Standard devices \- Incus documentation

[https://linuxcontainers.org/incus/docs/main/reference/standard_devices/](https://linuxcontainers.org/incus/docs/main/reference/standard_devices/)

[\[11\]](https://stackoverflow.com/questions/56419346/how-does-the-libc-function-isatty-work#:~:text=10) c \- How does the libc function isatty() work? \- Stack Overflow

[https://stackoverflow.com/questions/56419346/how-does-the-libc-function-isatty-work](https://stackoverflow.com/questions/56419346/how-does-the-libc-function-isatty-work)

[\[12\]](https://github.com/neovim/neovim/issues/14049#:~:text=dev%2Fstdin%20not%20available%20in%20system,terminals%29) dev/stdin not available in system() · Issue \#14049 \- GitHub

[https://github.com/neovim/neovim/issues/14049](https://github.com/neovim/neovim/issues/14049)

[\[13\]](https://lists.gnu.org/archive/html/help-bash/2025-02/msg00051.html#:~:text=,descriptor%201%20is%20duplicated) Re: Why does MacOS always append to a redirected file descriptor ...

[https://lists.gnu.org/archive/html/help-bash/2025-02/msg00051.html](https://lists.gnu.org/archive/html/help-bash/2025-02/msg00051.html)

[\[18\]](https://eclecticlight.co/2024/06/26/how-file-systems-can-change-in-sequoia-with-fskit/#:~:text=Apple%E2%80%99s%20long,we%20have%20heard%20of%20it) [\[19\]](https://eclecticlight.co/2024/06/26/how-file-systems-can-change-in-sequoia-with-fskit/#:~:text=Before%20you%20all%20rush%20to,macFUSE%20anyone) How file systems can change in Sequoia with FSKit – The Eclectic Light Company

[https://eclecticlight.co/2024/06/26/how-file-systems-can-change-in-sequoia-with-fskit/](https://eclecticlight.co/2024/06/26/how-file-systems-can-change-in-sequoia-with-fskit/)
