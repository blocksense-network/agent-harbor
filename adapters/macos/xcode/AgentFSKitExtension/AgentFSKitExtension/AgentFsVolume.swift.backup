
import Foundation
import FSKit
import os

@_silgen_name("agentfs_bridge_statfs")
func agentfs_bridge_statfs(_ core: UnsafeMutableRawPointer?, _ buffer: UnsafeMutablePointer<CChar>?, _ buffer_size: size_t) -> Int32

@_silgen_name("agentfs_bridge_stat")
func agentfs_bridge_stat(_ core: UnsafeMutableRawPointer?, _ path: UnsafePointer<CChar>?, _ buffer: UnsafeMutablePointer<CChar>?, _ buffer_size: size_t) -> Int32

@_silgen_name("agentfs_bridge_mkdir")
func agentfs_bridge_mkdir(_ core: UnsafeMutableRawPointer?, _ path: UnsafePointer<CChar>?, _ mode: UInt32) -> Int32

@_silgen_name("agentfs_bridge_readdir")
func agentfs_bridge_readdir(_ core: UnsafeMutableRawPointer?, _ path: UnsafePointer<CChar>?, _ buffer: UnsafeMutablePointer<CChar>?, _ buffer_size: size_t) -> Int32

@_silgen_name("agentfs_bridge_open")
func agentfs_bridge_open(_ core: UnsafeMutableRawPointer?, _ path: UnsafePointer<CChar>?, _ options: UnsafePointer<CChar>?, _ handle: UnsafeMutablePointer<UInt64>?) -> Int32

@_silgen_name("agentfs_bridge_read")
func agentfs_bridge_read(_ core: UnsafeMutableRawPointer?, _ handle: UInt64, _ offset: UInt64, _ buffer: UnsafeMutableRawPointer?, _ length: UInt32, _ bytes_read: UnsafeMutablePointer<UInt32>?) -> Int32

@_silgen_name("agentfs_bridge_write")
func agentfs_bridge_write(_ core: UnsafeMutableRawPointer?, _ handle: UInt64, _ offset: UInt64, _ buffer: UnsafeRawPointer?, _ length: UInt32, _ bytes_written: UnsafeMutablePointer<UInt32>?) -> Int32

@_silgen_name("agentfs_bridge_close")
func agentfs_bridge_close(_ core: UnsafeMutableRawPointer?, _ handle: UInt64) -> Int32

@_silgen_name("agentfs_bridge_snapshot_create")
func agentfs_bridge_snapshot_create(_ core: UnsafeMutableRawPointer?, _ name: UnsafePointer<CChar>?, _ snapshot_id: UnsafeMutablePointer<CChar>?, _ snapshot_id_size: size_t) -> Int32

@_silgen_name("agentfs_bridge_branch_create")
func agentfs_bridge_branch_create(_ core: UnsafeMutableRawPointer?, _ snapshot_id: UnsafePointer<CChar>?, _ branch_name: UnsafePointer<CChar>?, _ branch_id: UnsafeMutablePointer<CChar>?, _ branch_id_size: size_t) -> Int32

@_silgen_name("agentfs_bridge_bind_process")
func agentfs_bridge_bind_process(_ core: UnsafeMutableRawPointer?, _ branch_id: UnsafePointer<CChar>?) -> Int32

@available(macOS 15.4, *)
final class AgentFsVolume: FSVolume {

    private let resource: FSResource
    private let coreHandle: UnsafeMutableRawPointer?

    private let logger = Logger(subsystem: "com.agentfs.AgentFSKitExtension", category: "AgentFsVolume")

    private let root: AgentFsItem

    init(resource: FSResource, coreHandle: UnsafeMutableRawPointer?) {
        self.resource = resource
        self.coreHandle = coreHandle

        // Create root item with fixed attributes
        self.root = AgentFsItem.createRoot()

        super.init(
            volumeID: FSVolume.Identifier(uuid: Constants.volumeIdentifier),
            volumeName: FSFileName(string: "AgentFS")
        )
    }

}

@available(macOS 15.4, *)
extension AgentFsVolume: FSVolume.PathConfOperations {

    var maximumLinkCount: Int {
        return -1
    }

    var maximumNameLength: Int {
        return -1
    }

    var restrictsOwnershipChanges: Bool {
        return false
    }

    var truncatesLongNames: Bool {
        return false
    }

    var maximumXattrSize: Int {
        return Int.max
    }


@available(macOS 15.4, *)
extension AgentFsVolume: FSVolume.Operations {

    var supportedVolumeCapabilities: FSVolume.SupportedCapabilities {
        logger.debug("supportedVolumeCapabilities")

        let capabilities = FSVolume.SupportedCapabilities()
        capabilities.supportsHardLinks = true
        capabilities.supportsSymbolicLinks = true
        capabilities.supportsPersistentObjectIDs = true
        capabilities.doesNotSupportVolumeSizes = true
        capabilities.supportsHiddenFiles = true
        capabilities.supports64BitObjectIDs = true
        capabilities.caseFormat = .insensitiveCasePreserving // AgentFS will be case sensitive
        return capabilities
    }

    var volumeStatistics: FSStatFSResult {
        logger.debug("volumeStatistics")

        let result = FSStatFSResult(fileSystemTypeName: "AgentFS")

        // Call Rust bridge to get filesystem statistics
        var statfsBuffer = [CChar](repeating: 0, count: 1024)
        let statfsResult = agentfs_bridge_statfs(coreHandle, &statfsBuffer, statfsBuffer.count)

        if statfsResult == 0, let statfsJson = String(cString: statfsBuffer, encoding: .utf8) {
            // Parse JSON and set result fields
            if let data = statfsJson.data(using: .utf8),
               let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                result.blockSize = Int((json["block_size"] as? NSNumber)?.uint32Value ?? 4096)
                result.ioSize = Int((json["io_size"] as? NSNumber)?.uint32Value ?? 4096)
                result.totalBlocks = (json["total_blocks"] as? NSNumber)?.uint64Value ?? 1024 * 1024
                result.availableBlocks = (json["available_blocks"] as? NSNumber)?.uint64Value ?? 1024 * 1024
                result.freeBlocks = (json["free_blocks"] as? NSNumber)?.uint64Value ?? 1024 * 1024
                result.totalFiles = (json["total_files"] as? NSNumber)?.uint64Value ?? 1024 * 1024
                result.freeFiles = (json["free_files"] as? NSNumber)?.uint64Value ?? 1024 * 1024
            }
        } else {
            // Fallback to reasonable defaults
            result.blockSize = 4096
            result.ioSize = 4096
            result.totalBlocks = 1024 * 1024
            result.availableBlocks = 1024 * 1024
            result.freeBlocks = 1024 * 1024
            result.totalFiles = 1024 * 1024
            result.freeFiles = 1024 * 1024
        }

        return result
    }

    func activate(options: FSTaskOptions) async throws -> FSItem {
        logger.debug("activate")
        return root
    }

    func deactivate(options: FSDeactivateOptions = []) async throws {
        logger.debug("deactivate")
    }

    func mount(options: FSTaskOptions) async throws {
        logger.debug("mount")
        // TODO: Initialize volume state
    }

    func unmount() async {
        logger.debug("unmount")
        // TODO: Cleanup volume state
    }

    func synchronize(flags: FSSyncFlags) async throws {
        logger.debug("synchronize")
        // TODO: Implement synchronization
    }

    func attributes(
        _ desiredAttributes: FSItem.GetAttributesRequest,
        of item: FSItem
    ) async throws -> FSItem.Attributes {
        guard let item = item as? AgentFsItem else {
            logger.debug("getItemAttributes: invalid item type")
            throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
        }

        logger.debug("getItemAttributes: \(item.name), \(desiredAttributes)")

        // Call Rust bridge to get current attributes
        if let path = try? await pathForItem(item) {
            var statBuffer = [CChar](repeating: 0, count: 2048)
            let statResult = agentfs_bridge_stat(coreHandle, path, &statBuffer, statBuffer.count)

            if statResult == 0, let statJson = String(cString: statBuffer, encoding: .utf8) {
                if let data = statJson.data(using: .utf8),
                   let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                   let newAttributes = try? parseAttributesFromJson(json, currentAttributes: item.attributes) {
                    return newAttributes
                }
            }
        }

        // Fallback to cached attributes if bridge call fails
        return item.attributes
    }

    func setAttributes(
        _ newAttributes: FSItem.SetAttributesRequest,
        on item: FSItem
    ) async throws -> FSItem.Attributes {
        logger.debug("setItemAttributes: \(item), \(newAttributes)")
        if let item = item as? AgentFsItem {
            // TODO: Implement attribute setting (M15)
            mergeAttributes(item.attributes, request: newAttributes)
            return item.attributes
        } else {
            throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
        }
    }

    func lookupItem(
        named name: FSFileName,
        inDirectory directory: FSItem
    ) async throws -> (FSItem, FSFileName) {
        logger.debug("lookupName: \(String(describing: name.string)), \(directory)")

        guard let directory = directory as? AgentFsItem else {
            throw fs_errorForPOSIXError(POSIXError.ENOENT.rawValue)
        }

        // Handle special cases
        if let nameStr = name.string {
            if nameStr == "." {
                return (directory, name)
            } else if nameStr == ".." {
                // For now, everything's parent is root
                return (root, name)
            }
        }

        // Build the full path for lookup
        let dirPath = try await pathForItem(directory)
        let fullPath = dirPath == "/" ? "/\(name.string ?? "")" : "\(dirPath)/\(name.string ?? "")"

        // Handle special cases first
        if let nameStr = name.string {
            // Root directory special items
            if directory === root {
                if nameStr == ".agentfs" {
                    // Control directory for CLI operations (M16)
                    let controlDir = await AgentFsItem(name: name)
                    controlDir.attributes.parentID = root.attributes.fileID
                    controlDir.attributes.fileID = FSItem.Identifier(rawValue: await AgentFsItem.getNextID()) ?? .invalid
                    controlDir.attributes.type = FSItem.ItemType.directory
                    controlDir.attributes.mode = UInt32(S_IFDIR | 0o755)
                    controlDir.attributes.size = 4096
                    controlDir.attributes.allocSize = 4096
                    return (controlDir, name)
                }
            }

            // Handle lookup within .agentfs control directory
            if let directoryName = directory.name.string, directoryName == ".agentfs" {
                // Control files for CLI operations
                if nameStr == "snapshot" || nameStr == "branch" || nameStr == "bind" {
                    let controlFile = await AgentFsItem(name: name)
                    controlFile.attributes.parentID = directory.attributes.fileID
                    controlFile.attributes.fileID = FSItem.Identifier(rawValue: await AgentFsItem.getNextID()) ?? .invalid
                    controlFile.attributes.type = FSItem.ItemType.file
                    controlFile.attributes.mode = UInt32(S_IFREG | 0o644)
                    controlFile.attributes.size = 0
                    controlFile.attributes.allocSize = 0
                    return (controlFile, name)
                }
            }
        }

        // Try to look up the item via Rust bridge
        if let coreHandle = coreHandle {
            let pathCStr = fullPath.cString(using: .utf8)
            if let pathCStr = pathCStr {
                var statBuffer = [CChar](repeating: 0, count: 2048)
                let statResult = agentfs_bridge_stat(coreHandle, pathCStr, &statBuffer, statBuffer.count)

                if statResult == 0, let statJson = String(cString: statBuffer, encoding: .utf8) {
                    if let data = statJson.data(using: .utf8),
                       let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] {
                        // Create FSKit item from stat information
                        let item = await AgentFsItem(name: name)
                        item.attributes.parentID = directory.attributes.fileID
                        item.attributes.fileID = FSItem.Identifier(rawValue: await AgentFsItem.getNextID()) ?? .invalid

                        // Set attributes from JSON
                        if let fileId = json["file_id"] as? NSNumber {
                            item.attributes.fileID = FSItem.Identifier(rawValue: fileId.uint64Value) ?? item.attributes.fileID
                        }
                        if let size = json["size"] as? NSNumber {
                            item.attributes.size = size.uint64Value
                        }
                        if let allocSize = json["alloc_size"] as? NSNumber {
                            item.attributes.allocSize = allocSize.uint64Value
                        }
                        if let mode = json["mode"] as? NSNumber {
                            item.attributes.mode = mode.uint32Value
                            // Set file type based on mode
                            if (item.attributes.mode & UInt32(S_IFDIR)) == UInt32(S_IFDIR) {
                                item.attributes.type = .directory
                            } else if (item.attributes.mode & UInt32(S_IFLNK)) == UInt32(S_IFLNK) {
                                item.attributes.type = .file // FSKit doesn't have .symbolicLink
                            } else {
                                item.attributes.type = .file
                            }
                        }

                        // Set timestamps
                        let now = Date()
                        item.attributes.accessTime = now.timeIntervalSince1970
                        item.attributes.modifyTime = now.timeIntervalSince1970
                        item.attributes.changeTime = now.timeIntervalSince1970
                        item.attributes.birthTime = now.timeIntervalSince1970

                        return (item, name)
                    }
                }
            }
        }

        throw fs_errorForPOSIXError(POSIXError.ENOENT.rawValue)
    }

    func reclaimItem(_ item: FSItem) async throws {
        logger.debug("reclaimItem: \(item)")
        // TODO: Implement reclamation
    }

    func readSymbolicLink(
        _ item: FSItem
    ) async throws -> FSFileName {
        logger.debug("readSymbolicLink: \(item)")
        // TODO: Implement symlink reading
        throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
    }

    func createItem(
        named name: FSFileName,
        type: FSItem.ItemType,
        inDirectory directory: FSItem,
        attributes newAttributes: FSItem.SetAttributesRequest
    ) async throws -> (FSItem, FSFileName) {
        logger.debug("createItem: \(String(describing: name.string)) - \(newAttributes.mode)")

        guard let directory = directory as? AgentFsItem,
              let nameStr = name.string,
              let coreHandle = coreHandle else {
            throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
        }

        // Build full path
        let dirPath = directory.name.string ?? "/"
        let fullPath = dirPath == "/" ? "/\(nameStr)" : "\(dirPath)/\(nameStr)"

        // Determine mode based on type and attributes
        var mode: UInt32 = newAttributes.mode ?? 0
        if mode == 0 {
            if type == .directory {
                mode = UInt32(S_IFDIR | 0o755)
            } else {
                mode = UInt32(S_IFREG | 0o644)
            }
        }

        // Call Rust bridge to create the item
        let pathCStr = fullPath.cString(using: .utf8)
        if let pathCStr = pathCStr {
            let result = agentfs_bridge_mkdir(coreHandle, pathCStr, mode)
            if result != 0 {
                // Creation failed, throw appropriate error
                throw fs_errorForPOSIXError(POSIXError.ENOENT.rawValue) // TODO: Map actual error codes
            }
        } else {
            throw fs_errorForPOSIXError(POSIXError.EINVAL.rawValue)
        }

        // Create FSKit item representation
        let item = await AgentFsItem(name: name)
        mergeAttributes(item.attributes, request: newAttributes)
        item.attributes.parentID = directory.attributes.fileID
        item.attributes.fileID = FSItem.Identifier(rawValue: await AgentFsItem.getNextID()) ?? .invalid
        item.attributes.type = type
        item.attributes.mode = mode

        // Set size attributes
        if type == .directory {
            item.attributes.size = 4096
            item.attributes.allocSize = 4096
        } else {
            item.attributes.size = 0
            item.attributes.allocSize = 0
        }

        directory.addItem(item)

        return (item, name)
    }

    func createSymbolicLink(
        named name: FSFileName,
        inDirectory directory: FSItem,
        attributes newAttributes: FSItem.SetAttributesRequest,
        linkContents contents: FSFileName
    ) async throws -> (FSItem, FSFileName) {
        logger.debug("createSymbolicLink: \(name)")
        // TODO: Implement symlink creation
        throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
    }

    func createLink(
        to item: FSItem,
        named name: FSFileName,
        inDirectory directory: FSItem
    ) async throws -> FSFileName {
        logger.debug("createLink: \(name)")
        // TODO: Implement hard link creation
        throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
    }

    func removeItem(
        _ item: FSItem,
        named name: FSFileName,
        fromDirectory directory: FSItem
    ) async throws {
        logger.debug("remove: \(name)")
        // TODO: Implement removal
        throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
    }

    func renameItem(
        _ item: FSItem,
        inDirectory sourceDirectory: FSItem,
        named sourceName: FSFileName,
        to destinationName: FSFileName,
        inDirectory destinationDirectory: FSItem,
        overItem: FSItem?
    ) async throws -> FSFileName {
        logger.debug("rename: \(item)")
        // TODO: Implement renaming
        throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
    }

    func enumerateDirectory(
        _ directory: FSItem,
        startingAt cookie: FSDirectoryCookie,
        verifier: FSDirectoryVerifier,
        attributes: FSItem.GetAttributesRequest?,
        packer: FSDirectoryEntryPacker
    ) async throws -> FSDirectoryVerifier {
        logger.debug("enumerateDirectory: \(directory)")

        guard let directory = directory as? AgentFsItem else {
            throw fs_errorForPOSIXError(POSIXError.ENOENT.rawValue)
        }

        logger.debug("- enumerateDirectory - \(directory.name)")

        // Get directory path
        let dirPath = try await pathForItem(directory)

        // Try to enumerate directory via Rust bridge
        if let coreHandle = coreHandle {
            let pathCStr = dirPath.cString(using: .utf8)
            if let pathCStr = pathCStr {
                var readdirBuffer = [CChar](repeating: 0, count: 4096)
                let readdirResult = agentfs_bridge_readdir(coreHandle, pathCStr, &readdirBuffer, readdirBuffer.count)

                if readdirResult == 0, let readdirJson = String(cString: readdirBuffer, encoding: .utf8) {
                    if let data = readdirJson.data(using: .utf8),
                       let jsonArray = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]] {

                        var cookie: UInt64 = 1
                        for entry in jsonArray {
                            if let name = entry["name"] as? String,
                               let typeStr = entry["type"] as? String {

                                let itemType: FSItem.ItemType
                                switch typeStr {
                                case "directory":
                                    itemType = .directory
                                case "file":
                                    itemType = .file
                                case "symlink":
                                    itemType = .symbolicLink
                                default:
                                    itemType = .unknown
                                }

                                let itemID = FSItem.Identifier(rawValue: await AgentFsItem.getNextID()) ?? .invalid

                                // Create attributes if requested
                                var itemAttrs: FSItem.Attributes? = nil
                                if attributes != nil {
                                    itemAttrs = FSItem.Attributes()
                                    itemAttrs!.fileID = itemID
                                    itemAttrs!.parentID = directory.attributes.fileID
                                    itemAttrs!.type = itemType
                                    // Set basic attributes
                                    if itemType == .directory {
                                        itemAttrs!.mode = UInt32(S_IFDIR | 0o755)
                                        itemAttrs!.size = 4096
                                        itemAttrs!.allocSize = 4096
                                    } else {
                                        itemAttrs!.mode = UInt32(S_IFREG | 0o644)
                                        itemAttrs!.size = 0
                                        itemAttrs!.allocSize = 0
                                    }
                                }

                                _ = packer.packEntry(
                                    name: FSFileName(string: name),
                                    itemType: itemType,
                                    itemID: itemID,
                                    nextCookie: FSDirectoryCookie(cookie),
                                    attributes: itemAttrs
                                )
                                cookie += 1
                            }
                        }
                        return verifier
                    }
                }
            }
        }

        // Fallback to minimal directory listing if Rust bridge fails
        if directory === root {
            // Add "." entry
            _ = packer.packEntry(
                name: FSFileName(string: "."),
                itemType: .directory,
                itemID: directory.attributes.fileID,
                nextCookie: FSDirectoryCookie(1),
                attributes: attributes != nil ? directory.attributes : nil
            )

            // Add ".." entry (also points to root for simplicity)
            _ = packer.packEntry(
                name: FSFileName(string: ".."),
                itemType: .directory,
                itemID: directory.attributes.fileID,
                nextCookie: FSDirectoryCookie(2),
                attributes: attributes != nil ? directory.attributes : nil
            )

            // Add .agentfs control directory (M16)
            let controlDirID = await AgentFsItem.getNextID()
            let controlAttrs = FSItem.Attributes()
            controlAttrs.fileID = FSItem.Identifier(rawValue: controlDirID) ?? .invalid
            controlAttrs.parentID = directory.attributes.fileID
            controlAttrs.type = .directory
            controlAttrs.mode = UInt32(S_IFDIR | 0o755)
            controlAttrs.size = 4096
            controlAttrs.allocSize = 4096

            _ = packer.packEntry(
                name: FSFileName(string: ".agentfs"),
                itemType: .directory,
                itemID: FSItem.Identifier(rawValue: controlDirID) ?? .invalid,
                nextCookie: FSDirectoryCookie(3),
                attributes: attributes != nil ? controlAttrs : nil
            )
        } else if let directoryName = directory.name.string, directoryName == ".agentfs" {
            // List control files in .agentfs directory
            // Add "." entry
            _ = packer.packEntry(
                name: FSFileName(string: "."),
                itemType: .directory,
                itemID: directory.attributes.fileID,
                nextCookie: FSDirectoryCookie(1),
                attributes: attributes != nil ? directory.attributes : nil
            )

            // Add control files
            let controlFiles = ["snapshot", "branch", "bind"]
            for (index, fileName) in controlFiles.enumerated() {
                let fileID = await AgentFsItem.getNextID()
                let fileAttrs = FSItem.Attributes()
                fileAttrs.fileID = FSItem.Identifier(rawValue: fileID) ?? .invalid
                fileAttrs.parentID = directory.attributes.fileID
                fileAttrs.type = .file
                fileAttrs.mode = UInt32(S_IFREG | 0o644)
                fileAttrs.size = 0
                fileAttrs.allocSize = 0

                _ = packer.packEntry(
                    name: FSFileName(string: fileName),
                    itemType: .file,
                    itemID: FSItem.Identifier(rawValue: fileID) ?? .invalid,
                    nextCookie: FSDirectoryCookie(UInt64(index + 2)),
                    attributes: attributes != nil ? fileAttrs : nil
                )
            }
        }

        return FSDirectoryVerifier(0)
    }

    private func mergeAttributes(_ existing: FSItem.Attributes, request: FSItem.SetAttributesRequest) {
        if request.isValid(FSItem.Attribute.uid) {
            existing.uid = request.uid
        }

        if request.isValid(FSItem.Attribute.gid) {
            existing.gid = request.gid
        }

        if request.isValid(FSItem.Attribute.type) {
            existing.type = request.type
        }

        if request.isValid(FSItem.Attribute.mode) {
            existing.mode = request.mode
        }

        if request.isValid(FSItem.Attribute.linkCount) {
            existing.linkCount = request.linkCount
        }

        if request.isValid(FSItem.Attribute.flags) {
            existing.flags = request.flags
        }

        if request.isValid(FSItem.Attribute.size) {
            existing.size = request.size
        }

        if request.isValid(FSItem.Attribute.allocSize) {
            existing.allocSize = request.allocSize
        }

        if request.isValid(FSItem.Attribute.fileID) {
            existing.fileID = request.fileID
        }

        if request.isValid(FSItem.Attribute.parentID) {
            existing.parentID = request.parentID
        }

        // Handle timestamps
        let now = timespec()
        if request.isValid(FSItem.Attribute.accessTime) {
            existing.accessTime = now
        }

        if request.isValid(FSItem.Attribute.changeTime) {
            existing.changeTime = now
        }

        if request.isValid(FSItem.Attribute.modifyTime) {
            existing.modifyTime = now
        }

        if request.isValid(FSItem.Attribute.addedTime) {
            existing.addedTime = now
        }

        if request.isValid(FSItem.Attribute.birthTime) {
            existing.birthTime = now
        }

        if request.isValid(FSItem.Attribute.backupTime) {
            existing.backupTime = now
        }
    }
}


            throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
        }

        logger.debug("write: \(item) - offset: \(offset), size: \(contents.count)")

        guard let item = item as? AgentFsItem,
              let itemName = item.name.string,
              let coreHandle = coreHandle else {
            throw fs_errorForPOSIXError(POSIXError.EIO.rawValue)
        }

        // Check if this is a control file operation (M16)
        if isControlFile(itemName) {
            return try await handleControlFileWrite(item, itemName: itemName, contents: contents, offset: offset)
        }

        // Get the file path
        let path = try await pathForItem(item)

        // Try to open/write the file via Rust bridge
        if item.attributes.type == .file {
            let pathCStr = path.cString(using: .utf8)
            if let pathCStr = pathCStr {
                var handle: UInt64 = 0
                let optionsJson = #"{"write": true, "create": true}"#
                let optionsCStr = optionsJson.cString(using: .utf8)

                if let optionsCStr = optionsCStr {
                    let openResult = agentfs_bridge_open(coreHandle, pathCStr, optionsCStr, &handle)
                    if openResult == 0 && handle != 0 {
                        // Successfully opened file, now write to it
                        var bytesWritten: UInt32 = 0
                        let writeResult = contents.withUnsafeBytes { bufferPtr in
                            agentfs_bridge_write(coreHandle, handle, UInt64(offset), bufferPtr.baseAddress, UInt32(contents.count), &bytesWritten)
                        }

                        // Close the file handle
                        let _ = agentfs_bridge_close(coreHandle, handle)

                        if writeResult == 0 {
                            // Update item attributes
                            item.attributes.size = max(item.attributes.size, UInt64(offset) + UInt64(bytesWritten))
                            item.attributes.allocSize = item.attributes.size
                            return Int(bytesWritten)
                        }
                    }
                }
            }
        }

        // Fallback to in-memory storage for items created in our system
        if offset == 0 {
            // Overwrite
            item.data = contents
        } else {
            // Append/extend - simple implementation for now
            if item.data == nil {
                item.data = Data(count: Int(offset))
            }
            if let existingData = item.data, Int(offset) > existingData.count {
                // Extend with zeros
                item.data = existingData + Data(count: Int(offset) - existingData.count)
            }
            if var data = item.data {
                data.replaceSubrange(Int(offset)..<Int(offset) + contents.count, with: contents)
                item.data = data
            }
        }

        item.attributes.size = UInt64(item.data?.count ?? 0)
        item.attributes.allocSize = item.attributes.size

        return contents.count
    }

    private func isControlFile(_ name: String) -> Bool {
        // Check if this item is in the .agentfs directory
        return name == "snapshot" || name == "branch" || name == "bind"
    }

    private func handleControlFileWrite(_ item: AgentFsItem, itemName: String, contents: Data, offset: off_t) async throws -> Int {
        logger.debug("Control file write: \(itemName)")

        // For control files, we expect JSON commands
        // Accumulate the written data and process complete commands
        if offset == 0 {
            // Start new command
            item.data = contents
        } else {
            // Append to existing command
            if item.data == nil {
                item.data = Data(count: Int(offset))
            }
            if let existingData = item.data, Int(offset) > existingData.count {
                item.data = existingData + Data(count: Int(offset) - existingData.count)
            }
            if var data = item.data {
                data.replaceSubrange(Int(offset)..<Int(offset) + contents.count, with: contents)
                item.data = data
            }
        }

        // Check if we have a complete JSON command (look for newline or EOF)
        if let data = item.data,
           let jsonString = String(data: data, encoding: .utf8),
           jsonString.contains("\n") || jsonString.contains("\0") {

            // Process the command
            try await processControlCommand(itemName, jsonString: jsonString.trimmingCharacters(in: .whitespacesAndNewlines))

            // Clear the command buffer after processing
            item.data = Data()
        }

        return contents.count
    }

    private func processControlCommand(_ commandType: String, jsonString: String) async throws {
        logger.debug("Processing control command: \(commandType) - \(jsonString)")

        guard let coreHandle = coreHandle else {
            logger.error("No core handle available for control command")
            return
        }

        switch commandType {
        case "snapshot":
            try await processSnapshotCommand(jsonString, coreHandle: coreHandle)
        case "branch":
            try await processBranchCommand(jsonString, coreHandle: coreHandle)
        case "bind":
            try await processBindCommand(jsonString, coreHandle: coreHandle)
        default:
            logger.warning("Unknown control command: \(commandType)")
        }
    }

    private func processSnapshotCommand(_ jsonString: String, coreHandle: UnsafeMutableRawPointer) async throws {
        logger.info("Processing snapshot command: \(jsonString)")

        // Parse JSON to extract snapshot name
        if let data = jsonString.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let name = json["name"] as? String {

            // Call Rust bridge to create snapshot
            let nameCStr = name.cString(using: .utf8)
            if let nameCStr = nameCStr {
                var snapshotId = [CChar](repeating: 0, count: 64)
                let result = agentfs_bridge_snapshot_create(coreHandle, nameCStr, &snapshotId, snapshotId.count)

                if result == 0, let snapshotIdStr = String(cString: snapshotId, encoding: .utf8) {
                    logger.info("Successfully created snapshot: \(snapshotIdStr)")
                } else {
                    logger.error("Failed to create snapshot")
                }
            }
        } else {
            logger.error("Invalid snapshot command format")
        }
    }

    private func processBranchCommand(_ jsonString: String, coreHandle: UnsafeMutableRawPointer) async throws {
        logger.info("Processing branch command: \(jsonString)")

        // Parse JSON to extract snapshot_id and branch_name
        if let data = jsonString.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let snapshotId = json["snapshot_id"] as? String,
           let branchName = json["name"] as? String {

            // Call Rust bridge to create branch
            let snapshotIdCStr = snapshotId.cString(using: .utf8)
            let branchNameCStr = branchName.cString(using: .utf8)

            if let snapshotIdCStr = snapshotIdCStr, let branchNameCStr = branchNameCStr {
                var branchId = [CChar](repeating: 0, count: 64)
                let result = agentfs_bridge_branch_create(coreHandle, snapshotIdCStr, branchNameCStr, &branchId, branchId.count)

                if result == 0, let branchIdStr = String(cString: branchId, encoding: .utf8) {
                    logger.info("Successfully created branch: \(branchIdStr)")
                } else {
                    logger.error("Failed to create branch")
                }
            }
        } else {
            logger.error("Invalid branch command format")
        }
    }

    private func processBindCommand(_ jsonString: String, coreHandle: UnsafeMutableRawPointer) async throws {
        logger.info("Processing bind command: \(jsonString)")

        // Parse JSON to extract branch_id
        if let data = jsonString.data(using: .utf8),
           let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
           let branchId = json["branch_id"] as? String {

            // Call Rust bridge to bind process to branch
            let branchIdCStr = branchId.cString(using: .utf8)
            if let branchIdCStr = branchIdCStr {
                let result = agentfs_bridge_bind_process(coreHandle, branchIdCStr)

                if result == 0 {
                    logger.info("Successfully bound process to branch: \(branchId)")
                } else {
                    logger.error("Failed to bind process to branch")
                }
            }
        } else {
            logger.error("Invalid bind command format")
        }
    }

    // MARK: - Helper Functions

    /// Get the filesystem path for an item
    private func pathForItem(_ item: AgentFsItem) async throws -> String {
        var pathComponents: [String] = []
        var currentItem = item

        while currentItem !== root {
            let name = currentItem.name.string
            pathComponents.insert(name, at: 0)
            // For simplicity, assume parent is root for now
            // In a full implementation, this would traverse up the hierarchy
            break
        }

        return "/" + pathComponents.joined(separator: "/")
    }

    /// Parse attributes from JSON returned by Rust bridge
    @available(macOS 15.4, *)
    private func parseAttributesFromJson(_ json: [String: Any], currentAttributes: FSItem.Attributes) throws -> FSItem.Attributes {
        let attributes = currentAttributes.copy() as! FSItem.Attributes

        if let fileId = json["file_id"] as? NSNumber {
            attributes.fileID = FSItem.Identifier(rawValue: fileId.uint64Value) ?? attributes.fileID
        }

        if let parentId = json["parent_id"] as? NSNumber {
            attributes.parentID = FSItem.Identifier(rawValue: parentId.uint64Value) ?? attributes.parentID
        }

        if let size = json["size"] as? NSNumber {
            attributes.size = size.uint64Value
        }

        if let allocSize = json["alloc_size"] as? NSNumber {
            attributes.allocSize = allocSize.uint64Value
        }

        if let mode = json["mode"] as? NSNumber {
            attributes.mode = mode.uint32Value
        }

        if let uid = json["uid"] as? NSNumber {
            attributes.uid = uid.uint32Value
        }

        if let gid = json["gid"] as? NSNumber {
            attributes.gid = gid.uint32Value
        }

        if let linkCount = json["link_count"] as? NSNumber {
            attributes.linkCount = linkCount.uint32Value
        }

        if let flags = json["flags"] as? NSNumber {
            attributes.flags = flags.uint32Value
        }

        // Set file type based on mode
        if (attributes.mode & UInt32(S_IFDIR)) == UInt32(S_IFDIR) {
            attributes.type = .directory
        } else if (attributes.mode & UInt32(S_IFLNK)) == UInt32(S_IFLNK) {
            attributes.type = .file // FSKit doesn't have .symbolicLink
        } else {
            attributes.type = .file
        }

        // Set timestamps (simplified - using current time for all)
        let now = Date()
        attributes.accessTime = now.timeIntervalSince1970
        attributes.modifyTime = now.timeIntervalSince1970
        attributes.changeTime = now.timeIntervalSince1970
        attributes.birthTime = now.timeIntervalSince1970

        return attributes
    }
