use std::env;
use std::path::Path;

fn main() {
    // Generate C header file for Swift to import
    let out_dir = env::var("OUT_DIR").unwrap();
    let header_path = Path::new(&out_dir).join("agentfs_fskit.h");

    // For now, create a minimal header. In a real implementation,
    // this would be generated from the Rust code using bindgen or similar.
    let header_content = r#"// Auto-generated header for AgentFS FSKit bindings
// This file is generated by build.rs - do not edit manually

#ifndef AGENTFS_FSKIT_H
#define AGENTFS_FSKIT_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// Opaque handle types
typedef struct AgentFsCoreHandle AgentFsCoreHandle;

// Result codes
typedef enum {
    AGENTFS_OK = 0,
    AGENTFS_ERROR = 1,
    AGENTFS_NOT_FOUND = 2,
    AGENTFS_PERMISSION_DENIED = 3,
    AGENTFS_INVALID_ARGUMENT = 4,
    AGENTFS_OUT_OF_MEMORY = 5,
    AGENTFS_IO_ERROR = 6,
} AgentFsResult;

// File types
typedef enum {
    AGENTFS_FILE_TYPE_REGULAR = 0,
    AGENTFS_FILE_TYPE_DIRECTORY = 1,
    AGENTFS_FILE_TYPE_SYMLINK = 2,
} AgentFsFileType;

// File attributes structure
typedef struct {
    uint64_t file_id;
    uint64_t parent_id;
    uint64_t size;
    uint64_t alloc_size;
    uint32_t mode;
    uint32_t uid;
    uint32_t gid;
    uint32_t link_count;
    uint32_t flags;
    AgentFsFileType file_type;
    int64_t access_time_sec;
    int64_t access_time_nsec;
    int64_t modify_time_sec;
    int64_t modify_time_nsec;
    int64_t change_time_sec;
    int64_t change_time_nsec;
    int64_t birth_time_sec;
    int64_t birth_time_nsec;
} AgentFsAttributes;

// Directory entry structure
typedef struct {
    const char* name;
    AgentFsFileType file_type;
    uint64_t file_id;
} AgentFsDirEntry;

// Function declarations
#ifdef __cplusplus
extern "C" {
#endif

// Core lifecycle
AgentFsCoreHandle* agentfs_core_create(void);
void agentfs_core_destroy(AgentFsCoreHandle* handle);

// Filesystem operations
AgentFsResult agentfs_getattr(const AgentFsCoreHandle* handle, const char* path, AgentFsAttributes* attrs);
ssize_t agentfs_readdir(const AgentFsCoreHandle* handle, const char* path, AgentFsDirEntry** entries, size_t max_entries);
AgentFsResult agentfs_create(const AgentFsCoreHandle* handle, const char* path, AgentFsFileType file_type, uint32_t mode);
AgentFsResult agentfs_remove(const AgentFsCoreHandle* handle, const char* path);
ssize_t agentfs_read(const AgentFsCoreHandle* handle, const char* path, uint64_t offset, size_t size, uint8_t* buffer);
ssize_t agentfs_write(const AgentFsCoreHandle* handle, const char* path, uint64_t offset, size_t size, const uint8_t* buffer);
AgentFsResult agentfs_rename(const AgentFsCoreHandle* handle, const char* old_path, const char* new_path);
AgentFsResult agentfs_setattr(const AgentFsCoreHandle* handle, const char* path, const AgentFsAttributes* attrs);

// Snapshot and branch operations
AgentFsResult agentfs_snapshot_create(const AgentFsCoreHandle* handle, const char* label, char* snapshot_id, size_t id_size);
AgentFsResult agentfs_branch_create(const AgentFsCoreHandle* handle, const char* snapshot_id, const char* branch_name);
AgentFsResult agentfs_bind_process(const AgentFsCoreHandle* handle, const char* branch_name, uint32_t pid);

// Memory management
void agentfs_free_dir_entries(AgentFsDirEntry* entries, size_t count);
size_t agentfs_get_error_message(char* buffer, size_t buffer_size);

#ifdef __cplusplus
}
#endif

#endif // AGENTFS_FSKIT_H
"#;

    std::fs::write(&header_path, header_content).expect("Failed to write header file");
    println!("cargo:rerun-if-changed=build.rs");
}
