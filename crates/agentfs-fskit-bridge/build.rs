use std::env;
use std::path::Path;

fn main() {
    // Only link against sys crate when feature is enabled
    if std::env::var("CARGO_FEATURE_LINK_SYS").is_ok() {
        // Build and link the sys crate as a static library
        let sys_path = Path::new(env!("CARGO_MANIFEST_DIR"))
            .parent()
            .unwrap()
            .join("agentfs-fskit-sys");

        // Tell cargo to link against the sys crate
        println!("cargo:rustc-link-lib=static=agentfs_fskit_sys");
        println!(
            "cargo:rustc-link-search=native={}",
            sys_path
                .join("target")
                .join(env::var("PROFILE").unwrap_or_else(|_| "debug".to_string()))
                .display()
        );
    }

    // Generate Swift header for the bridge
    let out_dir = env::var("OUT_DIR").unwrap();
    let header_path = Path::new(&out_dir).join("AgentFSBridge.h");

    let header_content = r#"// Auto-generated Swift header for AgentFS Bridge
// This file is generated by build.rs - do not edit manually

#ifndef AGENTFS_BRIDGE_H
#define AGENTFS_BRIDGE_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

// Opaque handle types
typedef struct FsCore FsCore;

// Function declarations
#ifdef __cplusplus
extern "C" {
#endif

// Core lifecycle
FsCore* agentfs_bridge_core_create(void);
void agentfs_bridge_core_destroy(FsCore* core);

// Error handling
size_t agentfs_bridge_get_error_message(char* buffer, size_t buffer_size);

#ifdef __cplusplus
}
#endif

#endif // AGENTFS_BRIDGE_H
"#;

    std::fs::write(&header_path, header_content).expect("Failed to write header file");

    println!("cargo:rerun-if-changed=build.rs");
}
